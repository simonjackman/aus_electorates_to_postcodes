[
  {
    "objectID": "postcode_nsw_legislative_district.html",
    "href": "postcode_nsw_legislative_district.html",
    "title": "NSW 2023 legislative districts to postcodes: correspondence file & mapping application",
    "section": "",
    "text": "Inputs\nNot included in this repo for size and/or license restrictions:\n\nNSW Electoral Commission MapInfo file\nList of NSW addresses from the August 2022 G-NAF (the Geocoded National Address File).\n\nFor making maps, we use the (very good) approximations to postcode geographies provided in shapefiles published by the Australian Bureau of Statistics.\n\n\nMethodology\n\nEvery G-NAF address in NSW is geocoded using GDA94 or GDA 2020 CRS, the same CRS used for both the NSW legislative district MapInfo file and ABS postal area shape files.\nLocate each geo-coded NSW address from G-NAF in a NSW legislative district, using functions in the sf R package.\nFor each postcode, compute and report count and what proportion of its geo-coded addresses lie in each district.\nUse leaflet to build a JS mapping/visualization application.\nquarto assembles this document and the web application, in turn utilising Observable JS for table building and the call to leaflet (Section 8).\n\n\n\nRead G-NAF\n\n\nCode\ngnaf <- read_delim(file = gnaf_core, delim = \"|\")\nnsw_addresses <- gnaf %>%\n    rename_with(tolower) %>%\n    filter(state == \"NSW\")\nwrite.fst(nsw_addresses, path = here(\"data/gnaf_subset.fst\"))\nrm(gnaf)\n\n\n\n\nCode\nnsw_addresses <- read.fst(path = here(\"data/gnaf_subset.fst\"))\nnsw_geo <- nsw_addresses %>% \n  distinct(postcode,longitude,latitude)\n\nnsw_geo <- st_as_sf(nsw_geo,\n                    coords = c('longitude', 'latitude'),\n                    crs = st_crs(CRS(\"+init=EPSG:7843\"))\n                    )\n\n\nWe subset the G-NAF “core” file to NSW addresses, yielding 4,772,933 addresses, spanning 622 postcodes and 2,894,120 distinct geo-codes (latitude/longitude pairs).\n\n\nNSW state legislative districts\nWe read the MapInfo file supplied by the NSW Electoral Commission; this employs the GDA2020 CRS and contain the boundaries for NSW’s 93 electorate districts, to be used in the 2023 election (gazetted and proclaimed on 26 August 2021).\n\n\nCode\nnsw_shp <-\n  st_read(\n    dsn = here(\"data/StateElectoralDistrict2021_GDA2020.MID\"),\n    query = sprintf(\n      \"SELECT objectid, cadid, districtna from StateElectoralDistrict2021_GDA2020\"\n    )\n  )\nnsw_shp <- st_transform(nsw_shp, crs = CRS(\"+init=EPSG:7843\"))\nnsw_shp <- as(nsw_shp, \"sf\") %>% st_make_valid() \ngeojsonio::geojson_write(nsw_shp,file = here(\"data/nsw_shp.json\"))\n\n\n\n\nRead postcode shapefiles\nFor map-making later on, we read the ABS postal areas (postcode) shapefiles; the coordinates use the GDA2020 geodetic CRS, which corresponds to EPSG:7843 CRS used in the other data sets we utilize.\n\n\nCode\npoa_shp <-\n  st_read(\n    here(\"data/POA_2021_AUST_GDA2020_SHP/POA_2021_AUST_GDA2020.shp\"),\n  )\nst_crs(poa_shp) <- CRS(\"+init=EPSG:7843\")\npoa_shp <- st_transform(poa_shp, crs = CRS(\"+init=EPSG:7843\"))\npoa_shp <- as(poa_shp, \"sf\") %>% st_make_valid() \n\n\n\n\nMatching addresses to districts\nWe now match the unique, geo-coded NSW addresses to districts, the real “work” of this exercise being done by the call to sf::st_intersects in the function pfunc; we group the data by postcode and use processing these batches of data in parallel via furrr::future_map.\n\n\nCode\npfunc <- function(obj){\n  z <- st_intersects(obj$geometry,nsw_shp)\n  return(as.integer(z))\n}\n\nnsw_geo <- nsw_geo %>% \n  group_nest(postcode) %>% \n  mutate(\n    intersection = future_map(.x = data,\n                              .f = ~pfunc(.x))\n    ) %>% \n  ungroup()\n\nnsw_geo <- nsw_geo %>% \n  unnest(c(data,intersection))\n\nnsw_geo <- nsw_geo %>% \n  mutate(district = nsw_shp$districtna[intersection])\n\n\nWe merge the results back against the GNAF addresses for NSW:\n\n\nCode\ncoords <- st_coordinates(nsw_geo$geometry)\nnsw_geo <- nsw_geo %>% \n  mutate(longitude = coords[,1],\n         latitude = coords[,2]) %>% \n  select(-geometry) \n\nnsw_addresses <- left_join(nsw_addresses,\n                           nsw_geo,\n                           by = c(\"postcode\", \"longitude\", \"latitude\"))\nrm(nsw_geo,coords)\n\n\nWe also filter down to the subset of Australian postcodes that intersect NSW legislative districts:\n\n\nCode\npoa_shp <- poa_shp %>% \n  semi_join(nsw_addresses %>% distinct(postcode),\n            by = c(\"POA_CODE21\" = \"postcode\")) \npoa_shp_small <- poa_shp %>% \n  st_simplify(preserveTopology = TRUE, dTolerance = 5)\n\ngeojsonio::geojson_write(poa_shp_small,file = here(\"data/nsw_poa_shp.json\"))\n\n\n\n\nCounts of addresses by legislative district\nWe compute counts of addresses with postcodes within districts; we also compute\n\npercentage of a district’s addresses in a given postcode (per_of_district)\npercentage of a postcode’s addresses in a given district (per_of_postcode)\n\n\n\nCode\nout <- nsw_addresses %>% \n  count(district,postcode) %>% \n  group_by(district) %>% \n  mutate(per_of_district = n/sum(n)*100) %>% \n  ungroup() %>% \n  group_by(postcode) %>% \n  mutate(per_of_postcode = n/sum(n)*100) %>% \n  ungroup() %>% \n  arrange(district,desc(per_of_district))\n\nrm(nsw_addresses)\n\n\n\n\nCode\nojs_define(out_raw=out)\n\n\n\n\nLinked table and map\n\n\nCode\nout = transpose(out_raw)\nviewof theDistrict = Inputs.select(out.map(d => d.district),\n    {\n      label: \"District: \",\n      sort: true,\n      unique: true\n    }\n  )\nout_small = out.filter(d => d.district == theDistrict)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nInputs.table(\n  out_small,\n  {\n   format: {\n    per_of_district: x => x.toFixed(1),\n    per_of_postcode: x => x.toFixed(1)\n  },\n  rows: out_small.length + 10\n  }\n)\n\n\n\n\n\n\n\n\n\n\n\n     \n\n\nCode\nnsw_shp_json = await FileAttachment(\"data/nsw_shp.json\").json()\n\n\n\n\n\n\n\n\n\nCode\nwidth = 800\nheight = 650\npoa_shp_json = FileAttachment(\"data/nsw_poa_shp.json\").json()\n\nthePostcodes = out_small.map(d => d.postcode)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nL = require('leaflet@1.9.2')\n\nmap2 = {\n  let container = DOM.element ('div', { style: `width:${width}px;height:${height}px` });\n  yield container;\n  \n  let map = L.map(container)\n  let osmLayer = L.tileLayer('https://stamen-tiles-{s}.a.ssl.fastly.net/toner-lite/{z}/{x}/{y}{r}.{ext}', {\n      attribution: 'Map tiles by <a href=\"http://stamen.com\">Stamen Design</a>, <a href=\"http://creativecommons.org/licenses/by/3.0\">CC BY 3.0</a> &mdash; Map data &copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors',\n  subdomains: 'abcd',\n    minZoom: 0,\n    maxZoom: 25,\n    ext: 'png'\n  }).addTo(map);\n  \n  function districtFilter(feature) {\n    if(feature.properties.districtna === theDistrict) return true\n  }\n  \n  function postCodeFilter(feature) {\n    if(thePostcodes.includes(feature.properties.POA_CODE21)) return true;\n  }\n\n  function style(feature) {\n    return {\n        fillColor: \"blue\",\n        weight: 2,\n        opacity: 0.7,\n        color: 'blue',\n        fillOpacity: 0.0\n    };\n  }\n\n  // highlight function\n  function highlightFeature(e) {\n    var layer = e.target;\n\n    layer.setStyle({\n        fillOpacity: 0.5,\n        opacity: 1.0,\n        weight: 3\n    });\n    \n    layer.openTooltip();\n    \n    layer.bringToFront();\n  }\n\n  // mouseout\n  function resetHighlight(e) {\n    poaLayer.resetStyle(e.target);\n  }\n  \n  function onEachFeature(feature, layer) {\n    layer.bindTooltip(\"<div style='background:white; padding:1px 3px 1px 3px'><b>\" + feature.properties.POA_CODE21 + \"</b></div>\",\n                     {\n                        direction: 'right',\n                        permanent: false,\n                        sticky: true,\n                        offset: [10, 0],\n                        opacity: 1,\n                        className: 'leaflet-tooltip-own'\n                     });\n    layer.on({\n        mouseover: highlightFeature,\n        mouseout: resetHighlight\n    });\n  }\n\n  let DistLayer  = L.geoJson(nsw_shp_json, \n    {\n      filter: districtFilter,\n      weight: 5, \n      color: \"#cc00007f\",\n    }).bindPopup(function (Layer) {\n        return Layer.feature.properties.districtna;\n    }).addTo(map);\n\n  let poaLayer = L.geoJson(poa_shp_json,\n   {\n      filter: postCodeFilter,\n      style : style,\n      onEachFeature: onEachFeature\n    })\n    .addTo(map);\n\n  map.fitBounds(DistLayer.getBounds());\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWrite to file\n\n\nCode\nwrite.csv(out,\n          file = here(\"data/district_postcode_counts.csv\"),\n          row.names = FALSE)"
  }
]